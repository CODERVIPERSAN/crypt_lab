# -*- coding: utf-8 -*-
"""crypt.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hUNGIvJ3MH_hiFC74MNt-QVnytSifzwt
"""

import numpy as np

#exp 1a caesar cipher ,shift cipher

def string_to_arr(string):
  return np.array(list(map(ord,list(string.replace(" ","")))))-97


#support numpy array as input and ouput
def E(K,P):
  return (P+K)%26




def arr_to_string(arr):
  ord_list = arr+97
  return "".join([chr(num) for num in ord_list])

def D(K,P):
  return E(-K,P)

plain_text = "covid"
print("plain_text:",plain_text)
print()
vec_plain = string_to_arr(plain_text)
print("plain_text_vector",vec_plain)

#shift cipher K=7
cipher = E(7,vec_plain)
print("cipher_text_vector",cipher)
cipher_text = arr_to_string(cipher)
print()
print("cipher_text",cipher_text)

vec_plain = D(7,cipher)
print("plain_text_vector",vec_plain)
print()
plain_text = arr_to_string(vec_plain)
print("plain_text",plain_text)

#caesar cipher
cipher = E(3,vec_plain)
print("cipher_text_vector",cipher)
cipher_text = arr_to_string(cipher)
print()
print("cipher_text",cipher_text)

vec_plain = D(3,cipher)
print("plain_text_vector",vec_plain)
print()
plain_text = arr_to_string(vec_plain)
print("plain_text",plain_text)

#exp 1d vigenere chiper

def E(K,P):
  vector1=P
  vector2=K
  result = (vector1 + vector2[np.arange(len(vector1)) % len(vector2)])%26
  return result


def D(K,C):
  return E(-K,C)

key="security"
vec_plain = string_to_arr("cryptography")
cipher = E(string_to_arr(key),vec_plain)
print("cipher_text_vector",cipher)
cipher_text = arr_to_string(cipher)
print()
print("cipher_text",cipher_text)

vec_plain = D(string_to_arr(key),cipher)
print("plain_text_vector",vec_plain)
print()
plain_text = arr_to_string(vec_plain)
print("plain_text",plain_text)

#exp 1c hill cipher

def E(K,P):
  subarrays = np.split(P, len(P)/3)
  cipher_arr=[]
  for array in subarrays:
    cipher_arr +=[(array@K)%26]

  return np.concatenate(cipher_arr)



def D(K,C):
  return E(np.linalg.inv(K),C)




keymat = np.array(
[[ 1, 2, 1 ],
[ 2, 3, 2 ],
[2, 2, 1 ]])

keymat[[0,1],1]

np.split(np.array([1,2,3,4,5,6]),3)

value = np.array([1,2,3])
value@keymat

np.linalg.inv(keymat)

#preprocessing step
plain_text="mother theresa"
filler="x"
vec_plain = string_to_arr(plain_text)
remains = (3- len(vec_plain))%3
if remains:
  plain_text+=filler*remains

vec_plain = string_to_arr(plain_text)

cipher =  E(keymat,vec_plain)
print("cipher_text_vector",cipher)
cipher_text = arr_to_string(cipher)
print()
print("cipher_text",cipher_text)

plain = D(keymat,cipher)
print("plain_text_vector",plain.astype(int))
plain_text = arr_to_string(plain.astype(int))
print()
print("plain_text",plain_text)

# playfair cipher


plain_text="attarxar"

def generate_digram(plain_text):
  if(len(plain_text)==0):
    return plain_text
  elif(len(plain_text)==1):
    return plain_text+"x"
  elif (plain_text[0]==plain_text[1]):
    return plain_text[0]+"x"+generate_digram(plain_text[1:])
  else:
    return plain_text[0:2]+generate_digram(plain_text[2:])


digram = generate_digram(plain_text)
print("digram for the given plain_text: ",digram)

key="monarchy"

def remove_repetation(input_string):
  process_string=""
  for i in input_string:
    if(i not in process_string):
      process_string+=i
  return process_string


def create_mat(key):
  process_string = remove_repetation(key.replace("j","i"))
  arr1 = string_to_arr(process_string)
  for i in range(0,26):
    present = np.isin(i,arr1)
    if(i==9):
      continue
    elif(present):
      continue
    else:
      arr1 =np.append(arr1,i)
  return arr1.reshape(5,5)

key_mat = create_mat(key)

def E(K,P):
  digram = generate_digram(P)
  arr1 = string_to_arr(digram)

  temp = arr1.reshape(-1,2)
  cipher_lis=[]
  for value in temp:
    value1=value[0]
    value2=value[1]
    row1,col1 = np.where(K==value[0])
    row2,col2 = np.where(K==value[1])
    if (row1[0]==row2[0]):
      col1 = (col1+1)%5
      col2 = (col2+1)%5
    elif(col1[0]==col2[0]):
      row1=(row1+1)%5
      row2 =(row2+1)%5
    else:
      col1,col2=col2,col1
    cipher_lis+=[K[row1,col1],K[row2,col2]]

  return "".join([arr_to_string(txt) for txt in cipher_lis])


def D(K,P):
  digram = generate_digram(P)
  arr1 = string_to_arr(digram)

  temp = arr1.reshape(-1,2)
  cipher_lis=[]
  for value in temp:
    value1=value[0]
    value2=value[1]
    row1,col1 = np.where(K==value[0])
    row2,col2 = np.where(K==value[1])
    if (row1[0]==row2[0]):
      col1 = (col1-1)%5
      col2 = (col2-1)%5
    elif(col1[0]==col2[0]):
      row1=(row1-1)%5
      row2 =(row2-1)%5
    else:
      col1,col2=col2,col1
    cipher_lis+=[K[row1,col1],K[row2,col2]]

  return "".join([arr_to_string(txt) for txt in cipher_lis])

np.where(keymat==1)

cipher_text = E(key_mat,plain_text)

print("Cipher_text:",cipher_text)

plain_text = D(key_mat,cipher_text)

print("Plain_text:",plain_text)

#exp2 b

plain_text="hello world"
key="abcd"
len_key=len(key)
vec_plain = string_to_arr(plain_text)

plain_text+='x'*((len_key-len(vec_plain)%len_key)%len_key)
# vec_plain.reshape(-1,len(key))

def E(K,P):
  mat = string_to_arr(P).reshape(-1,len(K))
  key = string_to_arr(K)
  mat_trans=mat.T
  return mat_trans[key].flatten()

def D(K,C):
  mat = string_to_arr(C).reshape(len(K),-1)
  # print(mat,mat.shape)
  key = string_to_arr(K)
  # return mat[key].flatten()
  lis=[]
  for i in range(mat.shape[1]):
    lis+=[mat[sorted(key),i]]
  return np.array(lis).flatten()

cipher = E(key,plain_text)

cipher_text = arr_to_string(cipher)

cipher_text

#double encrption

double_cipher = E(key,cipher_text)

double_cipher_text = arr_to_string(double_cipher)
double_cipher_text

single_wrap = D(key,double_cipher_text)
#double_decrpytion
vec_plain = D(key,arr_to_string(single_wrap))

print("plain_text",arr_to_string(vec_plain))

vec_plain = D(key,cipher_text)

print(arr_to_string(vec_plain))

#exp2a railfence transposition technique

def encryptRailFence(text, key):
    rail = [['\n' for i in range(len(text))]
                for j in range(key)]

    dir_down = False
    row, col = 0, 0

    for i in range(len(text)):
        if (row == 0) or (row == key - 1):
            dir_down = not dir_down
        rail[row][col] = text[i]
        col += 1
        if dir_down:
            row += 1
        else:
            row -= 1

    result = []
    for i in range(key):
        for j in range(len(text)):
            if rail[i][j] != '\n':
                result.append(rail[i][j])
    return("" . join(result))

def decryptRailFence(cipher, key):

    rail = [['\n' for i in range(len(cipher))]
                for j in range(key)]

    dir_down = None
    row, col = 0, 0

    for i in range(len(cipher)):
        if row == 0:
            dir_down = True
        if row == key - 1:
            dir_down = False

        rail[row][col] = '*'
        col += 1

        if dir_down:
            row += 1
        else:
            row -= 1

    index = 0
    for i in range(key):
        for j in range(len(cipher)):
            if ((rail[i][j] == '*') and
            (index < len(cipher))):
                rail[i][j] = cipher[index]
                index += 1

    result = []
    row, col = 0, 0
    for i in range(len(cipher)):

        if row == 0:
            dir_down = True
        if row == key-1:
            dir_down = False

        if (rail[row][col] != '*'):
            result.append(rail[row][col])
            col += 1

        if dir_down:
            row += 1
        else:
            row -= 1
    return("".join(result))

if __name__ == "__main__":
    text1 = encryptRailFence("attack at once", 2)
    text2 = encryptRailFence("save me from danger", 3)
    text3 = encryptRailFence("defend the east wall", 3)

    print("cipher_text:","1",text1,"2",text2,"3",text3)



    print(decryptRailFence("s f gaem rmdneveoar", 3))
    print(decryptRailFence("atc toctaka ne", 2))
    print(decryptRailFence("dnhaweedtees alf  tl", 3))

pip install pycryptodome

from Crypto.Cipher import DES
from Crypto.Random import get_random_bytes
from Crypto.Util.Padding import pad, unpad

# Step 1: Generate a random 8-byte key for DES
des_key = get_random_bytes(8)

# Step 2: Create a Cipher instance for DES ECB mode
cipher = DES.new(des_key, DES.MODE_ECB)

# Step 3: Convert String into Byte[] array format
data_to_encrypt = b"Hello, this is a test message."

# Step 4: Encrypt the data
padded_data = pad(data_to_encrypt, DES.block_size)
encrypted_data = cipher.encrypt(padded_data)

# Step 5: Decrypt the data
decrypted_data = cipher.decrypt(encrypted_data)
unpadded_data = unpad(decrypted_data, DES.block_size)

print("Original data:", data_to_encrypt)
print("Encrypted data:", encrypted_data)
print("Decrypted data:", unpadded_data.decode('utf-8'))

import random

# Publicly shared values (usually large prime numbers)
p = 23  # Prime number
g = 5   # Generator

# Alice generates a private key
a_private = random.randint(1, p - 1)
print(a_private)
# Bob generates a private key
b_private = random.randint(1, p - 1)
print(b_private)
# Alice and Bob calculate their public keys
a_public = (g ** a_private) % p
b_public = (g ** b_private) % p

# They exchange their public keys over the insecure network

# Now, they calculate the shared secret
alice_shared_secret = (b_public ** a_private) % p
bob_shared_secret = (a_public ** b_private) % p

# Both Alice and Bob should have the same shared secret
if alice_shared_secret == bob_shared_secret:
    print("Shared Secret:", alice_shared_secret)
else:
    print("Key exchange failed")

# The shared secret can be used as a symmetric encryption key for secure communication
(g**(a_private*b_private))%p

from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes

# Encryption
def encrypt(plaintext, key):
    cipher = AES.new(key, AES.MODE_EAX)
    ciphertext, tag = cipher.encrypt_and_digest(plaintext)
    return ciphertext, cipher.nonce, tag

# Decryption
def decrypt(ciphertext, key, nonce, tag):
    cipher = AES.new(key, AES.MODE_EAX, nonce=nonce)
    plaintext = cipher.decrypt(ciphertext)
    try:
        cipher.verify(tag)
        return plaintext
    except ValueError:
        return None

# Example usage
if __name__ == '__main__':
    key = get_random_bytes(16)  # AES-128 key
    plaintext = b'This is a secret message.'

    ciphertext, nonce, tag = encrypt(plaintext, key)
    decrypted_text = decrypt(ciphertext, key, nonce, tag)

    if decrypted_text == plaintext:
        print("Encryption and decryption successful!")
        print(plaintext)
        print(ciphertext)
    else:
        print("Encryption and decryption failed!")

import hashlib

# Define the text you want to calculate the SHA-1 hash for
text = "This is the text for which we want to calculate the SHA-1 hash."

# Create a SHA-1 hash object
sha1 = hashlib.sha1()

# Update the hash object with the bytes of your text
sha1.update(text.encode('utf-8'))

# Calculate the SHA-1 hash
sha1_hash = sha1.hexdigest()

# Print the SHA-1 hash
print("SHA-1 Hash:", sha1_hash)

import hashlib
import random

class DigitalSignatureScheme:
    def __init__(self, p, q, g, private_key):
        self.p = p
        self.q = q
        self.g = g
        self.private_key = private_key
        self.public_key = pow(g, private_key, p)

    def generate_signature(self, message):
        K = random.randint(1, self.q - 1)
        message_hash = int(hashlib.sha256(message.encode()).hexdigest(), 16)

        R = pow(self.g, K, self.p) % self.q
        K_inverse = pow(K, -1, self.q)
        S = (K_inverse * (message_hash + self.private_key * R)) % self.q

        return (R, S)

    def verify_signature(self, message, signature):
        R, S = signature
        message_hash = int(hashlib.sha256(message.encode()).hexdigest(), 16)

        w = pow(S, -1, self.q)
        u1 = (message_hash * w) % self.q
        u2 = (R * w) % self.q

        v = ((pow(self.g, u1, self.p) * pow(self.public_key, u2, self.p)) % self.p) % self.q

        return v == R

p = 23
q = 11
g = 7
private_key = 3

dss = DigitalSignatureScheme(p, q, g, private_key)

message = "Hello, world!"
signature = dss.generate_signature(message)
print("Generated Signature:", signature)

is_valid = dss.verify_signature(message, signature)
print("Is Signature Valid?", is_valid)

from random import randint
import sympy

class DSAAlgorithm:
    @staticmethod
    def get_next_prime(ans):
        test = sympy.nextprime(int(ans))
        return test

    @staticmethod
    def find_q(n):
        start = 2
        while not sympy.isprime(n):
            while n % start != 0:
                start += 1
            n //= start
        return n

    @staticmethod
    def get_gen(p, q):
        h = randint(2, p)
        return pow(h, (p - 1) // q, p)

    @staticmethod
    def generate_signature(p, q, g, x, message):
        k = randint(2, q)
        r = pow(g, k, p) % q
        hash_val = int.from_bytes(message.encode(), byteorder='big')  # Simulating hash function
        k_inv = pow(k, -1, q)
        s = (k_inv * (hash_val + x * r)) % q
        return r, s

    @staticmethod
    def verify_signature(p, q, g, y, message, r, s):
        w = pow(s, -1, q)
        hash_val = int.from_bytes(message.encode(), byteorder='big')  # Simulating hash function
        u1 = (hash_val * w) % q
        u2 = (r * w) % q
        v = (pow(g, u1, p) * pow(y, u2, p) % p) % q
        return v == r

def main():
    p = DSAAlgorithm.get_next_prime("10600")
    q = DSAAlgorithm.find_q(p - 1)
    g = DSAAlgorithm.get_gen(p, q)

    x = randint(1, q)
    y = pow(g, x, p)

    message = "Hello, world!"
    print("\nSimulation of Digital Signature Algorithm\n")
    print("\nGlobal public key components are:\n")
    print("p is:", p)
    print("q is:", q)
    print("g is:", g)
    print("\nSecret information are:\n")
    print("x (private) is:", x)
    print("y (public) is:", y)
    print("\nGenerating digital signature:\n")
    r, s = DSAAlgorithm.generate_signature(p, q, g, x, message)
    print("r is:", r)
    print("s is:", s)

    print("\nVerifying digital signature (checkpoints):\n")
    signature_valid = DSAAlgorithm.verify_signature(p, q, g, y, message, r, s)
    if signature_valid:
        print("\nSuccess: Digital signature is verified!")
    else:
        print("\nError: Incorrect digital signature")

if __name__ == "__main__":
    main()